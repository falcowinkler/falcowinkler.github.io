<!doctype html>
<html lang="en">
<head>
<title></title>
<!-- 2021-09-05 Sun 16:57 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Falco Winkler">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<style>body { margin-bottom: 0px; }</style><script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script><link rel="stylesheet" type="text/css" href="css/python_course.css">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-3 col-md-push-9"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Relation of category theory to programming</a></li>
<li><a href="#sec-2">2. Philosophy</a></li>
<li><a href="#sec-3">3. What is a category</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. Exercises Chapter 1</a></li>
<li><a href="#sec-3-2">3.2. Exercises Chapter 2</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Functions, ephimorphisms</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. Isomorphisms</a></li>
<li><a href="#sec-4-2">4.2. Epimorphisms</a></li>
<li><a href="#sec-4-3">4.3. Monomorphisms</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Simple types</a></li>
<li><a href="#sec-6">6. Other categories that SET</a>
<ul class="nav">
<li><a href="#sec-6-1">6.1. Exercises (Chapter 3)</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</div><div class="col-md-9 col-md-pull-3"><h1 class="title"></h1>
<p>
yyyyyOriginal source 
(online-lecture): <a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_&amp;index=2&amp;t=0s">https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_&amp;index=2&amp;t=0s</a>
(book, exercises): <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/</a>
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Relation of category theory to programming</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Programming evolved from imperative, low-level (assembly) to more reusable (procedural, object oriented) languages
</li>
<li>Object oriented languages don't play well with concurrency, because they hide the wrong things: mutation and resource sharing between each other.
</li>
</ul>
<p>
Mixing mutation and resource sharing: "Data races"
</p>
<ul class="org-ul">
<li>Functional programming abstracts everything into functions, avoids mutations
</li>

<li>Every language has limits of what you can abstract "barrier of abstraction", even in haskell this is a very active frontier
</li>
<li>Here category theory becomes important: "Category theory is the higher level language above haskell, ml, assembly &#x2026;"
</li>
<li>Highest possible level of abstraction that percolates down to even languages like javascript, assembly
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Philosophy</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>Category theory found similarities between many fields of mathematics ("essentially all areas of mathematics")
</li>
<li>Type theory not invented for computer science, but to push other frontiers in mathematics. E.g. to talk about paradoxes (e.g. Russels, barber paradox)
</li>
<li>Russel initiated type theory
</li>
<li>Curry–Howard–Lambek correspondence describes an isomorphism between logic, type theory, and category theory
</li>

<li>The human brain evolved to solve problems by dividing them into smaller problems, which is why these seperate fields evolved
</li>
</ul>
<p>
without first seeing the "bigger" field/ theory.
</p>
<ul class="org-ul">
<li>Maybe seperability / composability are not the properties of the true nature of the universe, but our brains are just built in a way that they have to see structure everywhere
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> What is a category</h2>
<div class="outline-text-2" id="text-3">
<p>
The major tools in the "Toolbox" of our brain are
</p>
<ul class="org-ul">
<li>Abstractiont
</li>
<li>Composition
</li>
<li>Identity (are two things replaceable on a level of abstraction) (-&gt; Homotype type theory is a hot topic around this)
</li>
</ul>

<p>
Composition and identity define category theory
</p>

<p>
A category is a "bunch" of objects.
-&gt; We don't say a "set" of objects, because of the limitations of set theory (paradoxes, sets of sets, does a set contain itself etc.)
Morphisms are arrows between the objects.
</p>

<p>
Objects and morphisms are primitives of this theory with out any properties, other than arrows are between objects.
</p>
<ul class="org-ul">
<li>You can have 0 or more morphisms between objects, even uncountable number of arrows. In both directions.
</li>
<li>Morphisms can point from an object to that same object.
</li>
</ul>


<ul class="org-ul">
<li>Composition in this context means: Arrows for the "transitive closure" exist.
</li>

<li>Objects, morphisms and there composition completely define a <i>category</i>.
</li>
<li>For every object, an identity morphism \(id\) exists that points from an object to itself.
</li>
<li>\(id\) obeys left and right identity law
</li>
<li>Morphisms also obey associativity: \((h \circ g) \circ f = h \circ (g \circ f)\)
</li>
</ul>
<p>
<i>On the side</i>, if objects can form a <i>set</i>, the category is called <i>small</i> otherwise <b>large</b>.
</p>

<p>
Categories seem similar to an algebraic group, but they are not the same:
</p>
<ul class="org-ul">
<li>A group would be a category with one object
</li>
<li>The biggest distinction is that in categories, not everything is composeable
</li>
</ul>


<p>
Relation to programing: "A function is a morphism between two types"
</p>

<p>
What are types in programming languages? Simple definition: Types are sets, functions map between sets.
-&gt; When building a category to model this, we "forget" about the set elements and view these sets as "atoms" (objects). This is the "Set" category.
</p>

<p>
We throw all information away except morphisms 
</p>
</div>


<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Exercises Chapter 1</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li></li>
</ol>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">lambda</span> x: x
</pre>
</div>

<ol class="org-ol">
<li value="2"></li>
</ol>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">lambda</span> f,g:<span style="color: #4f97d7; font-weight: bold;">lambda</span> x: g<span style="color: #4f97d7;">(</span>f<span style="color: #bc6ec5;">(</span>x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> 
</pre>
</div>

<ol class="org-ol">
<li value="3"></li>
</ol>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #4f97d7;">id</span> = <span style="color: #4f97d7; font-weight: bold;">lambda</span> x: x
<span style="color: #7590db;">comp</span> = <span style="color: #4f97d7; font-weight: bold;">lambda</span> f,g:<span style="color: #4f97d7; font-weight: bold;">lambda</span> x: g<span style="color: #4f97d7;">(</span>f<span style="color: #bc6ec5;">(</span>x<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> 
<span style="color: #7590db;">plus1</span> = <span style="color: #4f97d7; font-weight: bold;">lambda</span> x: x+<span style="color: #a45bad;">1</span>
<span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7; font-weight: bold;">in</span> <span style="color: #4f97d7;">range</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">100</span><span style="color: #4f97d7;">)</span>:
    <span style="color: #4f97d7; font-weight: bold;">assert</span> comp<span style="color: #4f97d7;">(</span>plus1, <span style="color: #4f97d7;">id</span><span style="color: #4f97d7;">)(</span>i<span style="color: #4f97d7;">)</span> = i + <span style="color: #a45bad;">1</span>
    <span style="color: #4f97d7; font-weight: bold;">assert</span> comp<span style="color: #4f97d7;">(</span><span style="color: #4f97d7;">id</span>, plus1<span style="color: #4f97d7;">)(</span>i<span style="color: #4f97d7;">)</span> = i + <span style="color: #a45bad;">1</span>
</pre>
</div>

<ol class="org-ol">
<li value="4"></li>
</ol>
<p>
I think it largely depends what the objects are? If this is not specified, you could think of a way to model the web as a category that contains one object.
If the websites are objects, links are not composable, e.g. if a website A has a link to B and B has a link to C, A does not necessarily have a link to C.
</p>
<ol class="org-ol">
<li value="5">No because friendships are not transitive.
</li>
<li value="6">When you define your nodes as objects and (directed) links as morphisms, and the adjacency matrix contains it's transitive closure and the main diagonal is filled.
</li>
</ol>
<p>
Of course you can not represent any category with a graph like that, as multiple connections in the same direction, and infinite graphs / connections have to be possible.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Exercises Chapter 2</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li></li>
</ol>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #4f97d7; font-weight: bold;">from</span> functools <span style="color: #4f97d7; font-weight: bold;">import</span> lru_cache
<span style="color: #4f97d7; font-weight: bold;">import</span> time
<span style="color: #4f97d7; font-weight: bold;">from</span> random <span style="color: #4f97d7; font-weight: bold;">import</span> randint

<span style="color: #7590db;">memoize</span> = lru_cache<span style="color: #4f97d7;">(</span>maxsize=<span style="color: #a45bad;">None</span><span style="color: #4f97d7;">)</span>


<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">fib</span><span style="color: #4f97d7;">(</span>n<span style="color: #4f97d7;">)</span>:
    <span style="color: #4f97d7; font-weight: bold;">if</span> n == <span style="color: #a45bad;">0</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>
    <span style="color: #4f97d7; font-weight: bold;">elif</span> n == <span style="color: #a45bad;">1</span>:
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">1</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> fib<span style="color: #4f97d7;">(</span>n - <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span> + fib<span style="color: #4f97d7;">(</span>n - <span style="color: #a45bad;">2</span><span style="color: #4f97d7;">)</span>


<span style="color: #7590db;">fib</span> = memoize<span style="color: #4f97d7;">(</span>fib<span style="color: #4f97d7;">)</span>

<span style="color: #7590db;">before</span> = time.time<span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span>fib<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">333</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #7590db;">after</span> = time.time<span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"memoized fib took "</span>, after - before, <span style="color: #2d9574;">" s"</span><span style="color: #4f97d7;">)</span>

<span style="color: #7590db;">randint</span> = memoize<span style="color: #4f97d7;">(</span>randint<span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span>randint<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1</span>, <span style="color: #a45bad;">100</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span>randint<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1</span>, <span style="color: #a45bad;">100</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span>randint<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1</span>, <span style="color: #a45bad;">100</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>

<span style="color: #4f97d7; font-weight: bold;">import</span> random

<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">if we memoize the seed it obviously works </span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">because random() is deterministic</span>
<span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">in python we can also use Random's state:</span>

<span style="color: #4f97d7; font-weight: bold;">def</span> <span style="color: #bc6ec5; font-weight: bold;">rand_gen</span><span style="color: #4f97d7;">(</span>state<span style="color: #4f97d7;">)</span>:
    <span style="color: #7590db;">rand</span> = random.Random<span style="color: #4f97d7;">()</span>
    rand.setstate<span style="color: #4f97d7;">(</span>state<span style="color: #4f97d7;">)</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> rand.random<span style="color: #4f97d7;">()</span>, rand.getstate<span style="color: #4f97d7;">()</span>


<span style="color: #7590db;">rand_gen</span> = memoize<span style="color: #4f97d7;">(</span>rand_gen<span style="color: #4f97d7;">)</span>  <span style="color: #2aa1ae; background-color: #292e34;"># </span><span style="color: #2aa1ae; background-color: #292e34;">hash == state</span>

<span style="color: #7590db;">state</span> = random.Random<span style="color: #4f97d7;">()</span>.getstate<span style="color: #4f97d7;">()</span>
<span style="color: #7590db;">result</span>, <span style="color: #7590db;">next_state</span> = rand_gen<span style="color: #4f97d7;">(</span>state<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span>result<span style="color: #4f97d7;">)</span>
<span style="color: #7590db;">result</span>, <span style="color: #7590db;">next_state</span> = rand_gen<span style="color: #4f97d7;">(</span>next_state<span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7; font-weight: bold;">print</span><span style="color: #4f97d7;">(</span>result<span style="color: #4f97d7;">)</span>

</pre>
</div>

<pre class="example">
1751455877444438095408940282208383549115781784912085789506677971125378
memoized fib took  0.0004038810729980469  s
18
18
18
0.18610626833980448
0.274539025910999
</pre>


<ol class="org-ol">
<li value="4">a and d have no side effects.
</li>
<li value="5">We can map t, f to tt, tf, ff, ft so there are 4 functions
</li>
<li>(on paper)
</li>
</ol>


<figure>
<p><img src="/images/reading-notes/functional-programming/simple-types.svg" class="img-responsive" alt="simple-types.svg">
</p>
</figure>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Functions, ephimorphisms</h2>
<div class="outline-text-2" id="text-4">
<p>
A function is defined between sets / types where
</p>
<ul class="org-ul">
<li>the set the function is defined for is the <i>domain</i>
</li>
<li>the set of reachable values is the <i>image</i> that is a subset of the <i>codomain</i>
</li>
</ul>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Isomorphisms</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>\(f\) is an isomorphism if \(g \circ f = id\) and \(f \circ g = id\), meaning that there is a 1-1 correspondence between the two sets.
</li>
<li>Isomorphisms are defined for every category: the definition above uses just composition and identity.
</li>
<li>Isomorphisms are invertable (If a function is mapping to values to the same output, or if it's image does not fill the whole codomain, it is not invertible)
</li>
<li><i>Injective</i> functions map different vals to different outputs. (we "inject" in the codomain)
</li>
<li><i>Surjective</i> functions fill the whole codomain. 
</li>
<li><i>Injective + Surjective = Isomorphism</i>
</li>
</ul>
<p>
We can extend these definitions for set theory to category theory
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Epimorphisms</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>surjectivity in terms of categories?
</li>
<li>if we look at \(f : a \rightarrow b, g : b \rightarrow c\), f is surjective if it fills the whole domain b.
</li>
</ul>
<p>
In category theory we can express this with composition: f is surjective (in set theory) if for any two functions from \(b\) to \(c\),
the composition with f is the same. (Equality being defined by functional extensionality)
\(\forall g_1, g_2: g_1 \circ f = g_2 \circ f\)
</p>
<ul class="org-ul">
<li>Morphisms that have this properties are called epimorphisms
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Monomorphisms</h3>
<div class="outline-text-3" id="text-4-3">
<ol class="org-ol">
<li>If diffent values are mapped to different outputs, it must be true that, if we compose any \(g_1, g_2\) before f, and these compositions are equal,
</li>
</ol>
<p>
\(g_1, g_2\) must also be equal (otherwise f would have to map two outputs of \(g1\) and \(g_2\) to the same output value!
</p>
<ul class="org-ul">
<li>\(\forall g_1, g_2: f \circ g_1 = f \circ g_2 \rightarrow g_1 = g_2\)
</li>
<li>! Mono &amp; epic does not imply isomorphism !
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Simple types</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Void correspondence to the empty set (Falsity in logic), can be never constructed
</li>
<li>() is the singleton, can be always created
</li>
<li>functions from sinlgeton type to any type <i>enumerate</i> that type
</li>
<li>other types can be built of these two simple types
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Other categories that SET</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>Zero category: no objects
</li>
<li>One object category: One dot with one arrow to itself
</li>
<li>Monoid: one object arbitrarily many morphisms to itself. This is the same as a monoid in group theory,
</li>
</ul>
<p>
from the category theory perspective: The associative operation is induced by composition in \(HomSet\), and the identity element is
provided by \(id\). We can always extract a "classical" monoid from a "category" monoid.
</p>
<ul class="org-ul">
<li>Graphs can be categories, or made into categories (nodes are objects, links are morphisms) (called "free" categories)
</li>
<li>The category of all categories also exists (in this context, above simple categories become important)
</li>
<li>\(\leq\) is also a category (preorder). Categories that correspond to preorder are called "thin" categories: Zero or one arrows between all objects.
</li>
</ul>
<p>
More specific: \(\forall a,b: |C(a,b)| = 0\) or \(|C(a,b)| = 1\) where \(C(a,b)\) is the Hom-set (set of arrows) from a to b.
This category gives a good example for the fact that a morphism that is mono and epic, is not invertible.
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Exercises (Chapter 3)</h3>
<div class="outline-text-3" id="text-6-1">
<ol class="org-ol">
<li></li>
</ol>

<figure>
<p><img src="/images/reading-notes/functional-programming/free-categories.svg" class="img-responsive" alt="free-categories.svg">
</p>
</figure>

<ol class="org-ol">
<li value="2">a) The inclusion relation is a <i>partial order</i>. Set inclusion does not relate every set to every other set,
</li>
</ol>
<p>
e.g. $ {1} \nsubseteq {2} $. But we have transitivity: \(a \subseteq b, b \subseteq c \rightarrow a \subseteq c\).
b) Not too sure about c++ types but this might be a preorder. C++ has multi-inheritance right?
</p>

<ol class="org-ol">
<li value="3"></li>

<li>wrt. &amp;&amp;, Bool is a monoid with True as the neutral element. Using or (||), the neutral element is False. These claims, and the associativity of &amp;&amp; and || can be verified by writing out the truth tables, which i am too lazy to do here.
</li>
</ol>
</div>
</div>
</div>
</div></div></div>
</body>
</html>
