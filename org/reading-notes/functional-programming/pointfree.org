key takeaways for https://www.pointfree.co/
* Functions
Introduces operator ~|>~ (forward application) and ~>>>~ (forward composition).
#+BEGIN_SRC swift
  2 |> incr // == incr(2)
  (incr >>> square)(2) // 9
#+END_SRC
- Forward composition is the oposite of haskells ~.~ composition operator (~(b->c)->(a->b)->(a->c)~)
- Use precedencegroups to avoid writing brackets
- Use operators with care.
- Tooling suffers from Free functions + operators (no autocomplete)
- Methods don't compose as well, because they have to be associated with a value all the time
- Pointfree: never refer to the value you are processing, focus on functions and compositions
* Side effects
Side effects break composability, eg ~map $ map f~ can have
different side effects than ~map (f . f)~, but the same return value.

Take for example writing logs.
We can fix the problem of returning logs alongside the computation (~(_ x: Int) -> (Int, [String])~).
But for this kind of function/operator we need a new ~compose~ function that appends the logs from both function executions.

#+BEGIN_SRC swift
  func >=> <A, B, C>(
    _ f: @escaping (A) -> B?,
    _ g: @escaping (B) -> C?
    ) -> ((A) -> C?) {
  
    return { a in
        // same for lists and optionals:
        f(a).flatMap(g)
    }
  }
#+END_SRC
In haskell, it has type ~(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c~,
forward composition for monadic functions.

We can avoid having inputs from side effects with currying.
~<>~ is then defined as function composition for functions that return the input type.
(In haskell this is more generally defined on semigroups, namely: ~(<>) :: Semigroup a => a -> a -> a~.
* TODO UIKit styling with functions
* Algebraic data types
Composite types can also be called /algebraic data types/, because we can do algebra with them.
E.g. if an enum has cases for type A and B we can construct $A + B$ values from it, where in this notation,
$A$ and $B$ denote the number of values that can be constructed in the respective type. For pairs that's $A * B$.
~Void~ has 1 value and ~Never~ 0.
** Exercises
   1. Exponential. So for $A->B$, it has $B^A$ types. Because we choose a value from set $B$ $A$ times.
   2. ~List<A> = 1 + A * List<A>~
   3. ~Optional<Either<A, B>> = 1 + A + B~
      ~!= (A + 1) + (B + 1) = Either<Optional<A>, Optional<B>>~.
      In the second type there is ~Left nil~ and ~Right nil~ whereas in the first there is just ~nil~ for the absence of values.
   4. ~Either<Optional<A>, B> = 1+A+B = Optional<Either<A, B>>~. They are equivalent.
   5. Using the previous definitions for Pair and Either:
      #+BEGIN_SRC swift
        func * <A, B>(lhs: A.Type, rhs: B.Type) -> Pair<A, B>.Type {
          return Pair<A, B>.self
        }
        
        func + <A, B>(lhs: A.Type, rhs: B.Type) -> Either<A, B>.Type {
          return Either<A, B>.self
        }
      #+END_SRC
* Higher order functions
How can we fit functions that we work with every day into our composition?
We can define functions that manipulate functions such as ~curry~ and ~flip~ (equivalent to haskell).

How do we deal with methods?
Every method secretly defines a static function, which is already curried in the way that i'ts signature is always
~Self -> Arguments -> ReturnType~
/Zero argument functions/ can be a problem, because you have these empty parathesis flying around.
Solution: Zurry (zero argument curry).
#+BEGIN_SRC swift
  func zurry<A>(_ f: () -> A) -> A {
    return f()
  }
#+END_SRC

Generic and ~throws~ functions are problematic, but we can redefine functions such as ~map~ and ~filter~ to free, curried functions.
#+BEGIN_SRC swift
  func map<A, B>(_ f: @escaping (A) -> B) -> ([A]) -> [B] {
    return { $0.map(f) }
  }
#+END_SRC

What's the point? "When they work, they work really well, saving us a lot of boilerplate. 
When they don’t work, we’re still using the concepts and building intuitions for them."
** Exercises
   1. 3 argument curry
   #+BEGIN_SRC swift
     func curry<A, B, C, D>(_ f: @escaping (A, B, C) -> D) -> (A) -> (B) -> (C) -> D {
         return { a in { b in { c in f(a, b, c) } } }
     }
   #+END_SRC
   2. With e.g. URL.appendingPathComponent these tricks don't work, because you can not disambiguate the overloads.
   #+BEGIN_SRC swift
     let urlForPath = flip(curry(URL.init(fileURLWithPath:isDirectory:)))(true)
   #+END_SRC
   3. As we know from haskell, it's only right associative.
   #+BEGIN_SRC haskell
     A->B->C->D -- (A->(B->(C->D)))
   #+END_SRC
   4. uncurry
   #+BEGIN_SRC swift
     func uncurry<A, B, C>(_ f: @escaping (A) -> (B) -> C) -> (A, B) -> C {
         return { (a, b) in f(a)(b) }
     }
   #+END_SRC
   5. reduce
   #+BEGIN_SRC swift
     func reduce<A,E>(f: @escaping(A,E) -> A) -> ([E]) -> (A) -> A {
         return { l in { i in
                        l.reduce(i, f)
         }}
     }
   #+END_SRC
   6. pseudoEither:
   #+BEGIN_SRC swift     
     struct PseudoEither<A, B> {
         let left: A?
         let right: B?
     }
     
     func left<A, B>(a: A) -> PseudoEither<A, B> {
         PseudoEither(left: a, right: nil)
     }
     
     func right<A, B>(b: B)-> PseudoEither<A, B> {
         PseudoEither(left: nil, right: b)
     }
     
     let x: PseudoEither<String, Int> = left(a: "wuff")
     let y: PseudoEither<String, Int> = right(b: 42)
   #+END_SRC
   7. nested map
   #+BEGIN_SRC swift
     let arr = [[1, 2], [3, 4]]
     ((map >>> map) { $0 + 1 }) (arr) // [[2, 3], [4, 5]]
   #+END_SRC
* Setters and key paths
Key paths are generic over type they apply to, and the specific value, eg.
#+BEGIN_SRC swift
KeyPath<User, String>
#+END_SRC
you can use a keypath with array syntax!
#+BEGIN_SRC swift
user[keyPath: \User.name]
#+END_SRC
Key paths are compiler generated (generate setters/getters under the hood)


Use prop to compose functions over key paths
#+BEGIN_SRC swift
  func prop<Root, Value>(_ kp: WritableKeyPath<Root, Value>)
    -> (@escaping (Value) -> Value)
    -> (Root)
    -> Root
  
  (prop(\User.name)) { $0.uppercased() } // User -> User
  // composing:
  prop(\User.location) <<< prop(\Location.name)
  // ((String) -> String) -> (User) -> User
  // Even though that's equivalent to \User.location.name
#+END_SRC

~prop~ allows you to write neat date formatters, URLrequest configurations etc.
pointfree in one expression (without computed props/stateful funcs)..
** Exercises
   1. Dictionary’s subscript key path.
      #+BEGIN_SRC swift
      ((Value?) -> Value?) -> Dictionary<Key, Value> -> Dictionary<Key, Value>
      #+END_SRC
      The difference when piping map is that the optional in the signature vanishes, because we lift the
      transformation in it's monadic context (the monad being the maybe monad).
   2. Functional setters for sets
      #+BEGIN_SRC swift
        func elem<A>(_ a: (A)) -> (@escaping (Bool) -> Bool) -> (Set<A>) -> Set<A> {
            { f in
                { set in
                    var set = set
                    if (f(set.contains(a))) {
                        set.insert(a)
                    }
                    return set
                }
            }
        }
      #+END_SRC
   3. Array subscript key path on user
      Guess i misunderstood the task
      #+BEGIN_SRC swift
        prop(\User.favoriteFoods)({
            if $0.isEmpty {
                return []
            } else {
                return [$0.first!.uppercased()] + Array($0.dropFirst())
            }
        })
      #+END_SRC
      correctAnswer:
      #+BEGIN_SRC swift
        (prop(\User.favoriteFoods[0].name)) { $0.uppercased() }
      #+END_SRC
   4. filtering in place
      #+BEGIN_SRC swift
        (prop(\User.favoriteFoods) <<< filter) // (String -> Bool) -> User -> User
      #+END_SRC 
   5. We will use ~Result<Value, Error>~ from ~Foundation~.
      #+BEGIN_SRC swift
        let result = Result<Int, Error>.success(1)
        func value<V, E>(f: @escaping ((V)->V)) -> (Result<V, E>) -> (Result<V, E>) {
            { res in
                switch res {
                case .failure:
                    return res
                case .success(let v):
                    return Result<V, E>.success(f(v))
                }
            }
        }
        // Error defined equivalently for failure case.
      #+END_SRC
    6. No, there are no key paths for structs (Case paths from pointfree as an alternative)
    7. e.g. for prop, the mapper function returns Void, and we simply need to call it, rather than re-assigning.
       #+BEGIN_SRC swift
         func inoutProp<Root, Value>(_ kp: WritableKeyPath<Root, Value>)
         -> (@escaping (inout Value) -> ())
         -> (Root)
         -> Root {
             { f in
                 { root in
                     var root = root
                     f(&root[keyPath: kp])
                     return root
                 }
             }
         }
       #+END_SRC
