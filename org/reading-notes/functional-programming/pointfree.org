key takeaways for https://www.pointfree.co/
* Functions
Introduces operator ~|>~ (forward application) and ~>>>~ (forward composition).
#+BEGIN_SRC swift
  2 |> incr // == incr(2)
  (incr >>> square)(2) // 9
#+END_SRC
- Forward composition is the oposite of haskells ~.~ composition operator (~(b->c)->(a->b)->(a->c)~)
- Use precedencegroups to avoid writing brackets
- Use operators with care.
- Tooling suffers from Free functions + operators (no autocomplete)
- Methods don't compose as well, because they have to be associated with a value all the time
- Pointfree: never refer to the value you are processing, focus on functions and compositions
* Side effects
Side effects break composability, eg ~map $ map f~ can have
different side effects than ~map (f . f)~, but the same return value.

Take for example writing logs.
We can fix the problem of returning logs alongside the computation (~(_ x: Int) -> (Int, [String])~).
But for this kind of function/operator we need a new ~compose~ function that appends the logs from both function executions.

#+BEGIN_SRC swift
  func >=> <A, B, C>(
    _ f: @escaping (A) -> B?,
    _ g: @escaping (B) -> C?
    ) -> ((A) -> C?) {
  
    return { a in
        // same for lists and optionals:
        f(a).flatMap(g)
    }
  }
#+END_SRC
In haskell, it has type ~(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c~,
forward composition for monadic functions.

We can avoid having inputs from side effects with currying.
~<>~ is then defined as function composition for functions that return the input type.
(In haskell this is more generally defined on semigroups, namely: ~(<>) :: Semigroup a => a -> a -> a~.
* TODO UIKit styling with functions
* Algebraic data types
Composite types can also be called /algebraic data types/, because we can do algebra with them.
E.g. if an enum has cases for type A and B we can construct $A + B$ values from it, where in this notation,
$A$ and $B$ denote the number of values that can be constructed in the respective type. For pairs that's $A * B$.
~Void~ has 1 value and ~Never~ 0.
** Exercises
   1. Exponential. So for $A->B$, it has $B^A$ types. Because we choose a value from set $B$ $A$ times.
   2. ~List<A> = 1 + A * List<A>~
   3. ~Optional<Either<A, B>> = 1 + A + B~
      ~!= (A + 1) + (B + 1) = Either<Optional<A>, Optional<B>>~.
      In the second type there is ~Left nil~ and ~Right nil~ whereas in the first there is just ~nil~ for the absence of values.
   4. ~Either<Optional<A>, B> = 1+A+B = Optional<Either<A, B>>~. They are equivalent.
   5. Using the previous definitions for Pair and Either:
      #+BEGIN_SRC swift
        func * <A, B>(lhs: A.Type, rhs: B.Type) -> Pair<A, B>.Type {
          return Pair<A, B>.self
        }
        
        func + <A, B>(lhs: A.Type, rhs: B.Type) -> Either<A, B>.Type {
          return Either<A, B>.self
        }
      #+END_SRC
* Higher order functions
How can we fit functions that we work with every day into our composition?
We can define functions that manipulate functions such as ~curry~ and ~flip~ (equivalent to haskell).

How do we deal with methods?
Every method secretly defines a static function, which is already curried in the way that i'ts signature is always
~Self -> Arguments -> ReturnType~
/Zero argument functions/ can be a problem, because you have these empty parathesis flying around.
Solution: Zurry (zero argument curry).
#+BEGIN_SRC swift
  func zurry<A>(_ f: () -> A) -> A {
    return f()
  }
#+END_SRC

Generic and ~throws~ functions are problematic, but we can redefine functions such as ~map~ and ~filter~ to free, curried functions.
#+BEGIN_SRC swift
  func map<A, B>(_ f: @escaping (A) -> B) -> ([A]) -> [B] {
    return { $0.map(f) }
  }
#+END_SRC

What's the point? "When they work, they work really well, saving us a lot of boilerplate. 
When they don’t work, we’re still using the concepts and building intuitions for them."
** Exercises
   1. 3 argument curry
   #+BEGIN_SRC swift
     func curry<A, B, C, D>(_ f: @escaping (A, B, C) -> D) -> (A) -> (B) -> (C) -> D {
         return { a in { b in { c in f(a, b, c) } } }
     }
   #+END_SRC
   2. With e.g. URL.appendingPathComponent these tricks don't work, because you can not disambiguate the overloads.
   #+BEGIN_SRC swift
     let urlForPath = flip(curry(URL.init(fileURLWithPath:isDirectory:)))(true)
   #+END_SRC
   3. As we know from haskell, it's only right associative.
   #+BEGIN_SRC haskell
     A->B->C->D -- (A->(B->(C->D)))
   #+END_SRC
   4. uncurry
   #+BEGIN_SRC swift
     func uncurry<A, B, C>(_ f: @escaping (A) -> (B) -> C) -> (A, B) -> C {
         return { (a, b) in f(a)(b) }
     }
   #+END_SRC
   5. reduce
   #+BEGIN_SRC swift
     func reduce<A,E>(f: @escaping(A,E) -> A) -> ([E]) -> (A) -> A {
         return { l in { i in
                        l.reduce(i, f)
         }}
     }
   #+END_SRC
   6. pseudoEither:
   #+BEGIN_SRC swift     
     struct PseudoEither<A, B> {
         let left: A?
         let right: B?
     }
     
     func left<A, B>(a: A) -> PseudoEither<A, B> {
         PseudoEither(left: a, right: nil)
     }
     
     func right<A, B>(b: B)-> PseudoEither<A, B> {
         PseudoEither(left: nil, right: b)
     }
     
     let x: PseudoEither<String, Int> = left(a: "wuff")
     let y: PseudoEither<String, Int> = right(b: 42)
   #+END_SRC
   7. nested map
   #+BEGIN_SRC swift
     let arr = [[1, 2], [3, 4]]
     ((map >>> map) { $0 + 1 }) (arr) // [[2, 3], [4, 5]]
   #+END_SRC
* Functional setters
If you modify data structures (by returning a copy), you will end up repeating a lot of code for transforming just one value.
Solution: Define generic functions for applying a function on a property.
This reduces boilerplate especially when types are modified, because you need a new copy everytime the type changes.
#+BEGIN_SRC swift
pair
  |> first(incr)
  |> first(String.init)
  |> second(zurry(flip(String.uppercased)))
// ("43", "SWIFT")
#+END_SRC
To compose functions within setters, we need to take care that it is done in the correct order.
E.g.
#+BEGIN_SRC swift
  let nested = ((1, true), "Swift")
  nested
  |> (second >>> first) { !$0 }
// ((1, false), "Swift")
#+END_SRC
Setter composition /composes backwards/.
Setters /lift/ a transformation on an individual value into a function operating
on the surrounding datatype.
** Exercises
   1. optional setters
   #+BEGIN_SRC swift
     func map<A>(f: @escaping ((A)->A)) -> (A?) -> A? {
         { optional in
             optional.flatMap(f)
         }
     }
     struct Dog {
         let age: Int?
         let name: String
     }
     
     func propDogAge(f: @escaping (Int) -> Int) -> (Dog) -> Dog {
         { dog in
             Dog(age: map(f: f)(dog.age), name: dog.name)
         }
     }
     
     let snoopy = Dog(age: 1, name: "snoopy")
     
     snoopy |>
       propDogAge(f: { n in n+1 })
   #+END_SRC
   2. For the ~Dog~ struct above:
   #+BEGIN_SRC swift
     func propDogName(f: @escaping (String) -> String) -> (Dog) -> Dog {
         { dog in
             Dog(age: dog.age, name: f(dog.name))
         }
     }
   #+END_SRC
   Problems: Setters are a lot of boilerplate, and it doesn't scale well with many properties
   3.
   #+BEGIN_SRC swift
     struct Dog {
         let name: String
         let location: Location
     }
     
     struct Location {
         let name: String
     }
     
     func dogLocationName(f: @escaping (String) -> String) -> (Dog) -> Dog {
         { dog in
             Dog(name: f(dog.name), location: Location(name: f(dog.location.name)))
         }
     }
     
     func dogLocation(f: @escaping (Location) -> Location) -> (Dog) -> Dog {
         { dog in
             Dog(name: dog.name, location: f(dog.location))
         }
     }
     
     func locationName(f: @escaping (String) -> String) -> (Location) -> Location {
         { location in
             Location(name: f(location.name))
         }
     }
     
     let snoopy = Dog(name: "snoopy", location: Location(name: "central park"))
     
     snoopy |> dogLocationName { $0 + "!" }
     snoopy |> (locationName >>> dogLocation) { $0 + "!" }
     snoopy |> (dogLocation <<< locationName) { $0 + "!" }
   #+END_SRC
   4. Yes we can, but for each tuple type you have to write these functions again.
   5. and 6.
   #+BEGIN_SRC swift
     func setKey<K, V>(f: @escaping (V?)->V?) -> (K) -> (Dictionary<K, V>) -> Dictionary<K, V> {
     {
         key in
         { dict in 
             var dict = dict
             if dict[key] !=  nil { // 6.
                 dict[key] = f(dict[key])
             }
             return dict
         }
     }
     }
   #+END_SRC
   7. The former is the signature of a setter, with the transformation as first argument. The latter can not be a setter,
      because it does not allow for the passing of a transformation value.
      In other words: The first signature receives a transformation function $A \rightarrow B$ whereas the second
      receives two values, one of type $A$ and one of type $B$.
* Setters and key paths
Key paths are generic over type they apply to, and the specific value, eg.
#+BEGIN_SRC swift
KeyPath<User, String>
#+END_SRC
you can use a keypath with array syntax!
#+BEGIN_SRC swift
user[keyPath: \User.name]
#+END_SRC
Key paths are compiler generated (generate setters/getters under the hood)


Use prop to compose functions over key paths
#+BEGIN_SRC swift
  func prop<Root, Value>(_ kp: WritableKeyPath<Root, Value>)
    -> (@escaping (Value) -> Value)
    -> (Root)
    -> Root
  
  (prop(\User.name)) { $0.uppercased() } // User -> User
  // composing:
  prop(\User.location) <<< prop(\Location.name)
  // ((String) -> String) -> (User) -> User
  // Even though that's equivalent to \User.location.name
#+END_SRC

~prop~ allows you to write neat date formatters, URLrequest configurations etc.
pointfree in one expression (without computed props/stateful funcs)..
** Exercises
   1. Dictionary’s subscript key path.
      #+BEGIN_SRC swift
      ((Value?) -> Value?) -> Dictionary<Key, Value> -> Dictionary<Key, Value>
      #+END_SRC
      The difference when piping map is that the optional in the signature vanishes, because we lift the
      transformation in it's monadic context (the monad being the maybe monad).
   2. Functional setters for sets
      #+BEGIN_SRC swift
        func elem<A>(_ a: (A)) -> (@escaping (Bool) -> Bool) -> (Set<A>) -> Set<A> {
            { f in
                { set in
                    var set = set
                    if (f(set.contains(a))) {
                        set.insert(a)
                    }
                    return set
                }
            }
        }
      #+END_SRC
   3. Array subscript key path on user
      Guess i misunderstood the task
      #+BEGIN_SRC swift
        prop(\User.favoriteFoods)({
            if $0.isEmpty {
                return []
            } else {
                return [$0.first!.uppercased()] + Array($0.dropFirst())
            }
        })
      #+END_SRC
      correctAnswer:
      #+BEGIN_SRC swift
        (prop(\User.favoriteFoods[0].name)) { $0.uppercased() }
      #+END_SRC
   4. filtering in place
      #+BEGIN_SRC swift
        (prop(\User.favoriteFoods) <<< filter) // (String -> Bool) -> User -> User
      #+END_SRC 
   5. We will use ~Result<Value, Error>~ from ~Foundation~.
      #+BEGIN_SRC swift
        let result = Result<Int, Error>.success(1)
        func value<V, E>(f: @escaping ((V)->V)) -> (Result<V, E>) -> (Result<V, E>) {
            { res in
                switch res {
                case .failure:
                    return res
                case .success(let v):
                    return Result<V, E>.success(f(v))
                }
            }
        }
        // Error defined equivalently for failure case.
      #+END_SRC
    6. No, there are no key paths for structs (Case paths from pointfree as an alternative)
    7. e.g. for prop, the mapper function returns Void, and we simply need to call it, rather than re-assigning.
       #+BEGIN_SRC swift
         func inoutProp<Root, Value>(_ kp: WritableKeyPath<Root, Value>)
         -> (@escaping (inout Value) -> ())
         -> (Root)
         -> Root {
             { f in
                 { root in
                     var root = root
                     f(&root[keyPath: kp])
                     return root
                 }
             }
         }
       #+END_SRC

* Getters and key paths
Use ~get~ wrapper to bridge between function and keypath world
#+BEGIN_SRC swift
func get<Root, Value>(_ kp: KeyPath<Root, Value>) -> (Root) -> Value {
  return { root in
    root[keyPath: kp]
  }
}
#+END_SRC
this is nice:
#+BEGIN_SRC swift

users
  .filter(get(\.isStaff) >>> (!))
#+END_SRC
you can do operators as functions 💡.

Generic getters can also be helpful for sorting, max etc. because there you need a compare function
~A -> A -> Bool~.
With ~their~, we can write
#+BEGIN_SRC swift
users
  .max(by: their(get(\.email), <)) // we can also use Comparable instead of passing the compare fn.
#+END_SRC

We can also write a wrapper for combining elements in ~reduce~:
#+BEGIN_SRC swift
episodes.reduce(0, combining(get(\.viewCount), by: +))
#+END_SRC
We use get a lot, so you might consider using an operator ~^~ as prefix operator.

** Exercises
   1. Find three more standard library APIs that can be used with our get and ^ helpers:
      - ~filter~ a list of items on a boolean property
      - ~Dictionary<A, B>.init(grouping:, by:)~, grouping by an int property
      - ~contains(where:)~
      - other maps such as ~compact~ or ~flatMap~, ~mapValues~ etc.
   2. A getter key-path for zero-argument functions wrapping a property...
      cant think of others
   3. I am not sure if this is what is meant:
      #+BEGIN_SRC swift
        func getFoodAttr<T>(f: KeyPath<Food, T>) -> (User) -> [T] {
            { user in
                map(f: get(f))(user.favoriteFoods)
            }
        }
        getFoodAttr(f: \.name)(user) // Tacos, Nachos
      #+END_SRC
   4. Key paths support optional chaining
      #+BEGIN_SRC swift
        func getLocationAttr<T>(f: KeyPath<Location, T>) -> (User) -> T? {
            { user in
                map(f: get(f))(user.location)
            }
        }
        getLocationAttr(f: \.name)(user)
        let user2 = User(
            favoriteFoods: [],
            location: nil,
            name: "Blob"
        )
        get(\User.location?.name)(user2)
      #+END_SRC
   5. Like this?
      #+BEGIN_SRC swift
        func pluck<V, E>(r: Result<V, E>) -> V? {
            switch r {
            case .success(let v):
                return v
            default: return nil
            }
        }
        let res: Result<User, Error> = .success(user)
        map(f: get(\User.name))(pluck(r: res))
      #+END_SRC
   TODO: i don't really understand what is meant with 6,7,8 exercises.
* Algebraic Data Types: Exponents
As we learned in the exercises from "Algebraic Data Types",
there are $B^A$ functions of type $A->B$.
Since $a^b^c = a^(b*c)$, we can derive that
~C->B->A = (B, C) -> A~.
Shows that curry and uncurry are elemental operations.
Since $a^1 = a$, we can derive zurry and unzurry.

What happens with $a^0=1$?
~Never -> A = Void~
We can define absurd in swift!

#+BEGIN_SRC swift
func to<A>(_ f: (Never) -> A) -> Void {
  return ()
}
#+END_SRC
#+BEGIN_SRC swift
func from<A>(_ x: Void) -> (Never) -> A {
  return { never in
    switch never {
    }
  }
}
#+END_SRC
This can actually be useful, eg. in case of ~Result<Int, Never>~.

Remember that ~inout A -> Void~ can be transformed to ~A->A~?
This means that you can refactor ~(A,B) -> A~ into ~(inout A, B) -> Void~,
~(A, inout B) -> C~ to ~(A, B) -> (C, B)~ and such.

We can also see a correspondence between ~throws~ and ~Result<A, Error>~.

There is also the power law $a^(b+c) = a^b * a ^ c$, equivalent to
~Either<B, C> -> A = (B -> A, C -> A)~

💡We can use exponent laws to understand which functions can't and can not be simplified.

** Exercises
   1. $1^a = 1$
      ~Void <- a = Void~
      ~a -> Void = Void~
      #+BEGIN_SRC swift
        func to<A>(a: A) -> (Void) -> Void {
            { void in void }
        }
        
        func from<A>(void: Void) -> (A) -> Void {
            { a in void }
        }
      #+END_SRC
   2. Case 1: $0^a = 0 | a != 0$
      ~a -> Never = Never~
      #+BEGIN_SRC swift
        func from<A>(a: A) -> (Never) -> (Never) {
            { never in
                never
            }
        }
        
        func to<A>(never: Never) -> (A) -> (Never) {
            { a in
                never
            }
        }
      #+END_SRC
      Case 2: $0^a = undefined | a = 0$
   3. We will know in the next "Algebraic data types" episode 😌
   4. ~2^A = Set<A>~
      ~A -> Bool = Set<A>~
      So we can interpret a set as a function from A to Bool,
      that returns true if the element is contained, and false otherwise.
   5. 
       #+BEGIN_SRC swift
         func intersection<A>(a: @escaping ((A) -> Bool), b: @escaping (A) -> (Bool)) -> (A) -> Bool {
             { e in
                 return a(e) && b(e)
             }
         }
        
         func union<A>(a: @escaping ((A) -> Bool), b: @escaping (A) -> (Bool)) -> (A) -> Bool {
             { e in
                 return a(e) || b(e)
             }
         }
       #+END_SRC
   6. $(1+V)^K$
      Because we map from the key space to the value space with one additional element ~nil~.
   7. 
       #+BEGIN_SRC swift
         func to<A, B, C>(_ f: @escaping (Either<B, C>) -> A) -> ((B) -> A, (C) -> A) {
             ( { b in f(.left(b)) }
                 ,
               { c in f(.right(c)) }
             )
         }
        
         func from<A, B, C>(_ f: ((B) -> A, (C) -> A)) -> (Either<B, C>) -> A {
             let (bToA, cToA) = f
             return { bc in
                 switch bc {
                 case .left(let b):
                     return bToA(b)
                 case .right(let c):
                     return cToA(c)
                 }
             }
         }
       #+END_SRC
   8.
      #+BEGIN_SRC swift
        func to<A, B, C>(_ f: @escaping (C) -> (A, B)) -> ((C) -> A, (C) -> B) {
            ( { c in f(c).0 }
                ,
              { c in f(c).1 }
            )
        }
        
                func from<A, B, C>(_ f: ((C) -> A, (C) -> B)) -> (C) -> (A, B) {
            let (cToA, cToB) = f
            return { c in
                (cToA(c), cToB(c))
            }
        }
        
      #+END_SRC

* A tale of two flat maps
  ~flatMap~ is the mondaic bind.
  use ~compactMap~ to filter nil values.
** Exercises
   1. filtered:
     #+BEGIN_SRC swift
       func filtered<A>(_ lst: [A?]) -> [A] {
           lst.compactMap { x in x }
       }
     #+END_SRC
   2. 
       #+BEGIN_SRC swift
         func left<A, B>(_ either: Either<A, B>) -> A? {
             switch either {
             case .left(let l):
                 return l
             default:
                 return nil
             }
         }
        
         func right<A, B>(_ either: Either<A, B>) -> B? {
             switch either {
             case .right(let r):
                 return r
             default:
                 return nil
             }
         }
        
         func partitioned<A, B>(_ either: [Either<A,B>]) -> (left: [A], right: [B]) {
             ( either.compactMap(left)
                 ,
               either.compactMap(right)
             )
         }
        
       #+END_SRC
   3. 
       #+BEGIN_SRC swift
         func partitionMap<A, B, C>(
             _ optional: Optional<A>,
             _ f: @escaping ((A) -> Either<B, C>)) -> (Optional<B>, Optional<C>) {
             ( optional.flatMap(f >>> left)
                 ,
               optional.flatMap(f >>> right)
             )
         }
       #+END_SRC
   4. 
       #+BEGIN_SRC swift
         func filterMapValues<K, V, R>(_ d: Dictionary<K, V>) -> ((V) -> R?) -> [R] { { f in
             d.values.compactMap(f)
         }
         }
       #+END_SRC
   5. 
       #+BEGIN_SRC swift
         func partitionMapValues<K, V, A, B>(_ d: Dictionary<K, V>) -> ((V) -> Either<A, B>) -> (lefts: [A], rights: [B]) {
             { f in
                 Array(d.values).partitionMap(f)
             }
         }
       #+END_SRC
   6. 
       #+BEGIN_SRC swift       
         func optionalEither<A, B>(_ f: @escaping ((A) -> B?)) -> (A) -> Either<B, Void> {
             { a in
                 if let r = f(a) {
                     return .left(r)
                 } else {
                     return .right(())
                 }
             }
         }
         
         func filterMap<A, B>(_ f: @escaping ((A) -> B?), _ a: [A]) -> [B] {
             a.partitionMap(optionalEither(f)).lefts
         }
         
         func predicateOptional<A>(_ f: @escaping (A) -> Bool) -> (A) -> A? {
             { a in
                 f(a) ? a : nil
             }
         }
         
         func filter<A>(_ f: @escaping ((A) -> Bool), _ a: [A]) -> [A] {
             a.partitionMap(optionalEither(predicateOptional(f))).lefts
         }
       #+END_SRC
   7. Depends on what is allowed. You'd have to pass it two transformation functions for the left and the right case,
      that have the same ~Either<A,B>~ return type. Then you can partition into ~(Optional<A>, Optional<B>)~.
    
* Composition without operators
If operators are not the way to go, you can use named functions.
The problem is that you need an overload for any number of arguments.
This might change in the future for variadic generics.
** Exercises
   1.
      #+BEGIN_SRC swift
          func concat<A: AnyObject>(
              _ fs: ((inout A) -> Void)...
          )
          -> (inout A) -> Void {
              { a in fs.forEach { $0(&a) } }
          }
      #+END_SRC
   2.
      
      #+BEGIN_SRC swift
        func concat<A: AnyObject>(
            _ fs: ((A) -> A)...
        )
        -> (A) -> A {
            { x in
                return reduce(f: { a, f in f(a) })(fs)(x)
            }
        }
     #+END_SRC
   3. 
     #+BEGIN_SRC swift
       func compose<A, B, C>(_ f: @escaping (B)->C, _ g: @escaping(A) -> B) -> ((A) -> C) {
           { a in f(g(a)) }
       }
       
       struct Dog {
           var favoriteFood: DogFood
       }
       
       struct DogFood {
           var name: String
           var scrumptiousness: Int
       }
       
       let doggieBoy: Dog = compose(
         prop(\Dog.favoriteFood),
          prop(\DogFood.scrumptiousness))({$0+1})(
         Dog(favoriteFood: DogFood(name: "nuggers", scrumptiousness: 1999)
       ))
   #+END_SRC

* Tagged
We can use `Decodable` and `Encodable` to and from json.
Sometimes it can be desirable to wrap your datatypes with a custom type,
e.g. use an ~Email~ struct instead of just ~String~.
This can help avoid errors, because the compiler will complain if you pass other fields to
e.g. a ~sendEmail~ function.

Problem: If you have a custom struct, you need to adapt the json structure.
Or implement your custom ~Decodable~ instance.
Or use ~RawRepresentable~ which saves a lot of code.
You will have to tag on an ~Equatable~ though:
#+BEGIN_SRC swift
struct Subscription: Decodable {
  struct Id: Decodable, RawRepresentable, Equatable { let rawValue: Int }

  let id: Id
  let ownerId: Int
}
#+END_SRC
This is really need, but you're gonna repeat the three protocols all over again.
Akin to ~newtype~ in haskell we can use ~Tagged<Tag, Type>~:
#+BEGIN_SRC swift
struct Subscription: Decodable {
  typealias Id = Tagged<Subscription, Int>

  let id: Id
  let ownerId: User.Id
}
#+END_SRC
Tagged uses /Conditional conformance/ to implement ~Equatable~ and ~Decodable~:
#+BEGIN_SRC swift
extension Tagged: Equatable where RawValue: Equatable {
  static func == (lhs: Tagged, rhs: Tagged) -> Bool {
    return lhs.rawValue == rhs.rawValue
  }
}
#+END_SRC
If you have to instantiate ~Tagged~ fields yourself, it makes sense to use
~ExpressibleBy...Literal~ protocols.

** Exercises
   1. Expressible by string:
      #+BEGIN_SRC swift
        extension Tagged: ExpressibleByUnicodeScalarLiteral where RawValue: ExpressibleByStringLiteral {
            typealias UnicodeScalarLiteralType = String
        }
        
        extension Tagged: ExpressibleByExtendedGraphemeClusterLiteral where RawValue: ExpressibleByStringLiteral {
            init(extendedGraphemeClusterLiteral value: String) {
                self.init(stringLiteral: value as! RawValue.StringLiteralType)
            }
        }
        
        extension Tagged: ExpressibleByStringLiteral where RawValue: ExpressibleByStringLiteral {
            init(stringLiteral value: RawValue.StringLiteralType) {
                self.init(rawValue: RawValue(stringLiteral: value))
            }
        }
      #+END_SRC
   2. 
       #+BEGIN_SRC swift
         extension Tagged: Comparable where RawValue: Comparable {
             static func < (lhs: Tagged<Tag, RawValue>, rhs: Tagged<Tag, RawValue>) -> Bool {
                 return lhs.rawValue < rhs.rawValue
             }
         }
         // from swift-overture:
         public func their<Root, Value: Comparable>(
             _ getter: @escaping (Root) -> Value
         )
         -> (Root, Root) -> Bool {
             return their(getter, <)
         }
        
        
         users.sorted(by: their(\.id))
       #+END_SRC
   3. hmmmmm
      #+BEGIN_SRC swift
         enum AgeTag {}
         typealias Age = Tagged<AgeTag, Int>
      #+END_SRC
   4. 
* A Tour of the Composable Architecture: Part 1
  - Cohesive package to solve some problems that Swift UI has
  - Opinionated
  - Focus on modularization and composability
  - Very restrictive regarding side effects.
  - Assertion helper to test the composable architecture, that forces you to deal with all effects
  - Debugging capabilities (.debug to print all actions)
  - Range of example projects

  /Why view store?/
  - Hide state of sub-views so that the current view is only re-rendered when it's own state changes
  - More flexibility binding different front-ends to the state (platform-specific)

  Equatable for duplicate filtering
  Bindings
  For a list of states, there is a lot of index juggling in bare-metal CA
* A Tour of the Composable Architecture: Part 2
  We can get rid of index juggling with ~ForEachStore~
  On the reducer side we need to call forEach that supplies
  - Writable key path to a random access collection of subview-states
  - Case path of an action that embeds an index and action into a subview-action
    (could write this yourself with ~embed~ and ~extract~, but CasePaths supplies the backslash for this)
  - Function to create the environment. Or key path

  Strong type level guarantees

  ForEachStore can be used with stores that only knows about the collection, and the indexed actions.
  This is done with ~scope~, that extracts the list out of the state, and embeds an index action into the global actions.
  (/Extract global state into local, and embed local state into global/)

  Then extracting the subviews into their seperate views, the code becomes very short:
  #+BEGIN_SRC swift
    ForEachStore(
                  self.store.scope(
                      state: \.tiles,
                      action: MyActions.tileAction),
                  content: TileView.init)
  #+END_SRC
  ~combine~ multiple stores, if the global store also needs to handle some logic, that is unrelated to the list of subviews.
* A Tour of the Composable Architecture: Part 3
  Exhaustive tests with ~TestStore~.
  _Basic workflow:_
  1. Create a TestStore
     #+BEGIN_SRC swift
       let store = TestStore(
         initialState: AppState(
           todos: [
             Todo(
               description: "Milk",
               id: UUID(uuidString: "00000000-0000-0000-0000-000000000000")!,
               isComplete: false
             )
           ]
         ),
         reducer: appReducer,
         environment: AppEnvironment()
       )
     #+END_SRC
  2. Create exhaustive assertions (effects that are not tested will throw an error)
     #+BEGIN_SRC swift
       store.assert(
       .send(.todo(index: 0, action: .checkboxTapped)) {
         $0.todos = [
           Todo(
             description: "Eggs",
             id: UUID(uuidString: "00000000-0000-0000-0000-000000000001")!,
             isComplete: false
           ),
           Todo(
             description: "Milk",
             id: UUID(uuidString: "00000000-0000-0000-0000-000000000000")!,
             isComplete: true
           )
         ]
       }
       )
     #+END_SRC
  Some more wisdom:
  - Inject dependencies via environment
  - Be explicit in the assertions
  - use an inline struct to define your cancellable id's:
    #+BEGIN_SRC swift
      case .todo(index: _, action: .checkboxTapped):
      struct CancelDelayId: Hashable {}
      
      return Effect(value: .todoDelayCompleted)
        .delay(for: 1, scheduler: environment.mainQueue)
        .eraseToEffect()
        .cancellable(id: CancelDelayId(), cancelInFlight: true)
    #+END_SRC
* A Tour of the Composable Architecture: Part 4
  How to test async effects?
  Test helper will complain if some effects are still running.
  - don't use ~XCTWaiter~ and the like
  - Inject DispatchQueue using ~AnySchedulerOf<DispatchQueue>~ and use ~TestScheduler~ in the tests.
    You can then just ~advance~ your scheduler and don't have to wait.
  
