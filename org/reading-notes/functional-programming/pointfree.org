key takeaways for https://www.pointfree.co/
* Functions
Introduces operator ~|>~ (forward application) and ~>>>~ (forward composition).
#+BEGIN_SRC swift
  2 |> incr // == incr(2)
  (incr >>> square)(2) // 9
#+END_SRC
- Forward composition is the oposite of haskells ~.~ composition operator (~(b->c)->(a->b)->(a->c)~)
- Use precedencegroups to avoid writing brackets
- Use operators with care.
- Tooling suffers from Free functions + operators (no autocomplete)
- Methods don't compose as well, because they have to be associated with a value all the time
- Pointfree: never refer to the value you are processing, focus on functions and compositions
* Side effects
Side effects break composability, eg ~map $ map f~ can have
different side effects than ~map (f . f)~, but the same return value.

Take for example writing logs.
We can fix the problem of returning logs alongside the computation (~(_ x: Int) -> (Int, [String])~).
But for this kind of function/operator we need a new ~compose~ function that appends the logs from both function executions.

#+BEGIN_SRC swift
  func >=> <A, B, C>(
    _ f: @escaping (A) -> B?,
    _ g: @escaping (B) -> C?
    ) -> ((A) -> C?) {
  
    return { a in
        // same for lists and optionals:
        f(a).flatMap(g)
    }
  }
#+END_SRC
In haskell, it has type ~(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c~,
forward composition for monadic functions.

We can avoid having inputs from side effects with currying.
~<>~ is then defined as function composition for functions that return the input type.
(In haskell this is more generally defined on semigroups, namely: ~(<>) :: Semigroup a => a -> a -> a~.
* TODO UIKit styling with functions
* Algebraic data types
Composite types can also be called /algebraic data types/, because we can do algebra with them.
E.g. if an enum has cases for type A and B we can construct $A + B$ values from it, where in this notation,
$A$ and $B$ denote the number of values that can be constructed in the respective type. For pairs that's $A * B$.
~Void~ has 1 value and ~Never~ 0.
** Exercises
   1. Exponential. So for $A->B$, it has $B^A$ types. Because we choose a value from set $B$ $A$ times.
   2. ~List<A> = 1 + A * List<A>~
   3. ~Optional<Either<A, B>> = 1 + A + B~
      ~!= (A + 1) + (B + 1) = Either<Optional<A>, Optional<B>>~.
      In the second type there is ~Left nil~ and ~Right nil~ whereas in the first there is just ~nil~ for the absence of values.
   4. ~Either<Optional<A>, B> = 1+A+B = Optional<Either<A, B>>~. They are equivalent.
   5. Using the previous definitions for Pair and Either:
      #+BEGIN_SRC swift
        func * <A, B>(lhs: A.Type, rhs: B.Type) -> Pair<A, B>.Type {
          return Pair<A, B>.self
        }
        
        func + <A, B>(lhs: A.Type, rhs: B.Type) -> Either<A, B>.Type {
          return Either<A, B>.self
        }
      #+END_SRC
* Higher order functions
How can we fit functions that we work with every day into our composition?
We can define functions that manipulate functions such as ~curry~ and ~flip~ (equivalent to haskell).

How do we deal with methods?
Every method secretly defines a static function, which is already curried in the way that i'ts signature is always
~Self -> Arguments -> ReturnType~
/Zero argument functions/ can be a problem, because you have these empty parathesis flying around.
Solution: Zurry (zero argument curry).
#+BEGIN_SRC swift
  func zurry<A>(_ f: () -> A) -> A {
    return f()
  }
#+END_SRC

Generic and ~throws~ functions are problematic, but we can redefine functions such as ~map~ and ~filter~ to free, curried functions.
#+BEGIN_SRC swift
  func map<A, B>(_ f: @escaping (A) -> B) -> ([A]) -> [B] {
    return { $0.map(f) }
  }
#+END_SRC

What's the point? "When they work, they work really well, saving us a lot of boilerplate. 
When they don’t work, we’re still using the concepts and building intuitions for them."
** Exercises
   1. 3 argument curry
   #+BEGIN_SRC swift
     func curry<A, B, C, D>(_ f: @escaping (A, B, C) -> D) -> (A) -> (B) -> (C) -> D {
         return { a in { b in { c in f(a, b, c) } } }
     }
   #+END_SRC
   2. With e.g. URL.appendingPathComponent these tricks don't work, because you can not disambiguate the overloads.
   #+BEGIN_SRC swift
     let urlForPath = flip(curry(URL.init(fileURLWithPath:isDirectory:)))(true)
   #+END_SRC
   3. As we know from haskell, it's only right associative.
   #+BEGIN_SRC haskell
     A->B->C->D -- (A->(B->(C->D)))
   #+END_SRC
   4. uncurry
   #+BEGIN_SRC swift
     func uncurry<A, B, C>(_ f: @escaping (A) -> (B) -> C) -> (A, B) -> C {
         return { (a, b) in f(a)(b) }
     }
   #+END_SRC
   5. reduce
   #+BEGIN_SRC swift
     func reduce<A,E>(f: @escaping(A,E) -> A) -> ([E]) -> (A) -> A {
         return { l in { i in
                        l.reduce(i, f)
         }}
     }
   #+END_SRC
   6. pseudoEither:
   #+BEGIN_SRC swift     
     struct PseudoEither<A, B> {
         let left: A?
         let right: B?
     }
     
     func left<A, B>(a: A) -> PseudoEither<A, B> {
         PseudoEither(left: a, right: nil)
     }
     
     func right<A, B>(b: B)-> PseudoEither<A, B> {
         PseudoEither(left: nil, right: b)
     }
     
     let x: PseudoEither<String, Int> = left(a: "wuff")
     let y: PseudoEither<String, Int> = right(b: 42)
   #+END_SRC
   7. nested map
   #+BEGIN_SRC swift
     let arr = [[1, 2], [3, 4]]
     ((map >>> map) { $0 + 1 }) (arr) // [[2, 3], [4, 5]]
   #+END_SRC
* Functional setters
If you modify data structures (by returning a copy), you will end up repeating a lot of code for transforming just one value.
Solution: Define generic functions for applying a function on a property.
This reduces boilerplate especially when types are modified, because you need a new copy everytime the type changes.
#+BEGIN_SRC swift
pair
  |> first(incr)
  |> first(String.init)
  |> second(zurry(flip(String.uppercased)))
// ("43", "SWIFT")
#+END_SRC
To compose functions within setters, we need to take care that it is done in the correct order.
E.g.
#+BEGIN_SRC swift
  let nested = ((1, true), "Swift")
  nested
  |> (second >>> first) { !$0 }
// ((1, false), "Swift")
#+END_SRC
Setter composition /composes backwards/.
Setters /lift/ a transformation on an individual value into a function operating
on the surrounding datatype.
** Exercises
   1. optional setters
   #+BEGIN_SRC swift
     func map<A>(f: @escaping ((A)->A)) -> (A?) -> A? {
         { optional in
             optional.flatMap(f)
         }
     }
     struct Dog {
         let age: Int?
         let name: String
     }
     
     func propDogAge(f: @escaping (Int) -> Int) -> (Dog) -> Dog {
         { dog in
             Dog(age: map(f: f)(dog.age), name: dog.name)
         }
     }
     
     let snoopy = Dog(age: 1, name: "snoopy")
     
     snoopy |>
       propDogAge(f: { n in n+1 })
   #+END_SRC
   2. For the ~Dog~ struct above:
   #+BEGIN_SRC swift
     func propDogName(f: @escaping (String) -> String) -> (Dog) -> Dog {
         { dog in
             Dog(age: dog.age, name: f(dog.name))
         }
     }
   #+END_SRC
   Problems: Setters are a lot of boilerplate, and it doesn't scale well with many properties
   3.
   #+BEGIN_SRC swift
     struct Dog {
         let name: String
         let location: Location
     }
     
     struct Location {
         let name: String
     }
     
     func dogLocationName(f: @escaping (String) -> String) -> (Dog) -> Dog {
         { dog in
             Dog(name: f(dog.name), location: Location(name: f(dog.location.name)))
         }
     }
     
     func dogLocation(f: @escaping (Location) -> Location) -> (Dog) -> Dog {
         { dog in
             Dog(name: dog.name, location: f(dog.location))
         }
     }
     
     func locationName(f: @escaping (String) -> String) -> (Location) -> Location {
         { location in
             Location(name: f(location.name))
         }
     }
     
     let snoopy = Dog(name: "snoopy", location: Location(name: "central park"))
     
     snoopy |> dogLocationName { $0 + "!" }
     snoopy |> (locationName >>> dogLocation) { $0 + "!" }
     snoopy |> (dogLocation <<< locationName) { $0 + "!" }
   #+END_SRC
   4. Yes we can, but for each tuple type you have to write these functions again.
   5. and 6.
   #+BEGIN_SRC swift
     func setKey<K, V>(f: @escaping (V?)->V?) -> (K) -> (Dictionary<K, V>) -> Dictionary<K, V> {
     {
         key in
         { dict in 
             var dict = dict
             if dict[key] !=  nil { // 6.
                 dict[key] = f(dict[key])
             }
             return dict
         }
     }
     }
   #+END_SRC
   7. The former is the signature of a setter, with the transformation as first argument. The latter can not be a setter,
      because it does not allow for the passing of a transformation value.
      In other words: The first signature receives a transformation function $A \rightarrow B$ whereas the second
      receives two values, one of type $A$ and one of type $B$.
* Setters and key paths
Key paths are generic over type they apply to, and the specific value, eg.
#+BEGIN_SRC swift
KeyPath<User, String>
#+END_SRC
you can use a keypath with array syntax!
#+BEGIN_SRC swift
user[keyPath: \User.name]
#+END_SRC
Key paths are compiler generated (generate setters/getters under the hood)


Use prop to compose functions over key paths
#+BEGIN_SRC swift
  func prop<Root, Value>(_ kp: WritableKeyPath<Root, Value>)
    -> (@escaping (Value) -> Value)
    -> (Root)
    -> Root
  
  (prop(\User.name)) { $0.uppercased() } // User -> User
  // composing:
  prop(\User.location) <<< prop(\Location.name)
  // ((String) -> String) -> (User) -> User
  // Even though that's equivalent to \User.location.name
#+END_SRC

~prop~ allows you to write neat date formatters, URLrequest configurations etc.
pointfree in one expression (without computed props/stateful funcs)..
** Exercises
   1. Dictionary’s subscript key path.
      #+BEGIN_SRC swift
      ((Value?) -> Value?) -> Dictionary<Key, Value> -> Dictionary<Key, Value>
      #+END_SRC
      The difference when piping map is that the optional in the signature vanishes, because we lift the
      transformation in it's monadic context (the monad being the maybe monad).
   2. Functional setters for sets
      #+BEGIN_SRC swift
        func elem<A>(_ a: (A)) -> (@escaping (Bool) -> Bool) -> (Set<A>) -> Set<A> {
            { f in
                { set in
                    var set = set
                    if (f(set.contains(a))) {
                        set.insert(a)
                    }
                    return set
                }
            }
        }
      #+END_SRC
   3. Array subscript key path on user
      Guess i misunderstood the task
      #+BEGIN_SRC swift
        prop(\User.favoriteFoods)({
            if $0.isEmpty {
                return []
            } else {
                return [$0.first!.uppercased()] + Array($0.dropFirst())
            }
        })
      #+END_SRC
      correctAnswer:
      #+BEGIN_SRC swift
        (prop(\User.favoriteFoods[0].name)) { $0.uppercased() }
      #+END_SRC
   4. filtering in place
      #+BEGIN_SRC swift
        (prop(\User.favoriteFoods) <<< filter) // (String -> Bool) -> User -> User
      #+END_SRC 
   5. We will use ~Result<Value, Error>~ from ~Foundation~.
      #+BEGIN_SRC swift
        let result = Result<Int, Error>.success(1)
        func value<V, E>(f: @escaping ((V)->V)) -> (Result<V, E>) -> (Result<V, E>) {
            { res in
                switch res {
                case .failure:
                    return res
                case .success(let v):
                    return Result<V, E>.success(f(v))
                }
            }
        }
        // Error defined equivalently for failure case.
      #+END_SRC
    6. No, there are no key paths for structs (Case paths from pointfree as an alternative)
    7. e.g. for prop, the mapper function returns Void, and we simply need to call it, rather than re-assigning.
       #+BEGIN_SRC swift
         func inoutProp<Root, Value>(_ kp: WritableKeyPath<Root, Value>)
         -> (@escaping (inout Value) -> ())
         -> (Root)
         -> Root {
             { f in
                 { root in
                     var root = root
                     f(&root[keyPath: kp])
                     return root
                 }
             }
         }
       #+END_SRC

* Getters and key paths
Use ~get~ wrapper to bridge between function and keypath world
#+BEGIN_SRC swift
func get<Root, Value>(_ kp: KeyPath<Root, Value>) -> (Root) -> Value {
  return { root in
    root[keyPath: kp]
  }
}
#+END_SRC
this is nice:
#+BEGIN_SRC swift

users
  .filter(get(\.isStaff) >>> (!))
#+END_SRC
you can do operators as functions 💡.

Generic getters can also be helpful for sorting, max etc. because there you need a compare function
~A -> A -> Bool~.
With ~their~, we can write
#+BEGIN_SRC swift
users
  .max(by: their(get(\.email), <)) // we can also use Comparable instead of passing the compare fn.
#+END_SRC

We can also write a wrapper for combining elements in ~reduce~:
#+BEGIN_SRC swift
episodes.reduce(0, combining(get(\.viewCount), by: +))
#+END_SRC
We use get a lot, so you might consider using an operator ~^~ as prefix operator.

** Exercises
   1. Find three more standard library APIs that can be used with our get and ^ helpers:
      - ~filter~ a list of items on a boolean property
      - ~Dictionary<A, B>.init(grouping:, by:)~, grouping by an int property
      - ~contains(where:)~
      - other maps such as ~compact~ or ~flatMap~, ~mapValues~ etc.
   2. A getter key-path for zero-argument functions wrapping a property...
      cant think of others
   3. I am not sure if this is what is meant:
      #+BEGIN_SRC swift
        func getFoodAttr<T>(f: KeyPath<Food, T>) -> (User) -> [T] {
            { user in
                map(f: get(f))(user.favoriteFoods)
            }
        }
        getFoodAttr(f: \.name)(user) // Tacos, Nachos
      #+END_SRC
   4. Key paths support optional chaining
      #+BEGIN_SRC swift
        func getLocationAttr<T>(f: KeyPath<Location, T>) -> (User) -> T? {
            { user in
                map(f: get(f))(user.location)
            }
        }
        getLocationAttr(f: \.name)(user)
        let user2 = User(
            favoriteFoods: [],
            location: nil,
            name: "Blob"
        )
        get(\User.location?.name)(user2)
      #+END_SRC
   5. Like this?
      #+BEGIN_SRC swift
        func pluck<V, E>(r: Result<V, E>) -> V? {
            switch r {
            case .success(let v):
                return v
            default: return nil
            }
        }
        let res: Result<User, Error> = .success(user)
        map(f: get(\User.name))(pluck(r: res))
      #+END_SRC
   TODO: i don't really understand what is meant with 6,7,8 exercises.
